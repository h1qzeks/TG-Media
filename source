import os
import asyncio
import json
from pathlib import Path
from telethon import TelegramClient
from telethon.tl.types import InputPeerChannel
from tqdm import tqdm
from colorama import init, Fore, Style
import questionary
import sys
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                            QLineEdit, QPushButton, QComboBox, QProgressBar, 
                            QLabel, QFileDialog, QDialog, QHBoxLayout, QGroupBox, 
                            QMessageBox)
from PyQt6.QtCore import Qt, QPropertyAnimation, QEasingCurve, QSize, QUrl
from PyQt6.QtGui import QPalette, QColor, QDesktopServices
from qasync import QEventLoop
import telethon.errors
import io
import ctypes

if os.name == 'nt':
    whnd = ctypes.windll.kernel32.GetConsoleWindow()
    if whnd != 0:
        ctypes.windll.user32.ShowWindow(whnd, 0)
        ctypes.windll.kernel32.CloseHandle(whnd)

class GuiOutput(io.StringIO):
    def __init__(self, gui_callback):
        super().__init__()
        self.gui_callback = gui_callback
        
    def write(self, text):
        if self.gui_callback:
            self.gui_callback(text)
            
    def flush(self):
        pass

init(autoreset=True)

CONFIG_FILE = Path('tg_media_config.json')
DEFAULT_DOWNLOAD_FOLDER = 'telegram_downloads'

class GuiInputOutput(io.StringIO):
    def __init__(self, gui_callback):
        super().__init__()
        self.gui_callback = gui_callback
        
    def write(self, text):
        if self.gui_callback:
            self.gui_callback(text)
        
    def readline(self):
        return "\n"

class TelegramMediaDownloader:
    def __init__(self):
        self.config = self.load_config()
        self._client = None
        self.progress_callback = None
        self._auth_lock = asyncio.Lock()
        self._custom_input_callback = None
        self.status_callback = None

    def load_config(self):
        if CONFIG_FILE.exists():
            try:
                with open(CONFIG_FILE, 'r') as f:
                    config = json.load(f)
                    if config.get('last_choice') not in ['photo', 'video', 'both']:
                        config['last_choice'] = 'both'
                    if 'download_order' not in config:
                        config['download_order'] = 0
                    return config
            except json.JSONDecodeError:
                pass
        return {
            'api_id': '',
            'api_hash': '',
            'last_channel': '',
            'download_folder': DEFAULT_DOWNLOAD_FOLDER,
            'total_files': '20',
            'max_workers': '3',
            'last_choice': 'both',
            'download_order': 0
        }

    def save_config(self):
        self.config['download_order'] = self.config['download_order']
        with open(CONFIG_FILE, 'w') as f:
            json.dump(self.config, f, indent=4)

    async def show_header(self):
        os.system('cls' if os.name == 'nt' else 'clear')
        print(Fore.CYAN + r"""
                                                
  /$$$$$$   /$$$$$$  /$$$$$$$  /$$$$$$  /$$$$$$ 
 /$$__  $$ /$$__  $$| $$__  $$|_  $$_/ /$$__  $$
| $$  \__/| $$  \ $$| $$  \ $$  | $$  | $$  \__/
| $$ /$$$$| $$  | $$| $$  | $$  | $$  |  $$$$$$ 
| $$|_  $$| $$  | $$| $$  | $$  | $$   \____  $$
| $$  \ $$| $$  | $$| $$  | $$  | $$   /$$  \ $$
|  $$$$$$/|  $$$$$$/| $$$$$$$/ /$$$$$$|  $$$$$$/
 \______/  \______/ |_______/ |______/ \______/ 
         """ + Style.RESET_ALL)
        print(Fore.YELLOW + " Telegram Media Downloader Pro (@GODIS)" + Style.RESET_ALL)
        print(Fore.GREEN + "="*50 + Style.RESET_ALL)

    async def get_inputs(self):
        self.config['api_id'] = await questionary.text(
            "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à API ID:",
            default=self.config['api_id'],
            validate=lambda x: x.isdigit()
        ).ask_async()

        self.config['api_hash'] = await questionary.text(
            "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à API Hash:",
            default=self.config['api_hash']
        ).ask_async()

        self.config['last_channel'] = await questionary.text(
            "–í–≤–µ–¥–∏—Ç–µ @username –∏–ª–∏ ID –∫–∞–Ω–∞–ª–∞:",
            default=self.config['last_channel']
        ).ask_async()

        self.config['download_folder'] = await questionary.text(
            "–ü–∞–ø–∫–∞ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è:",
            default=self.config['download_folder']
        ).ask_async()

        self.config['total_files'] = await questionary.text(
            "–°–∫–æ–ª—å–∫–æ —Ñ–∞–π–ª–æ–≤ —Å–∫–∞—á–∞—Ç—å (0 = –≤—Å–µ):",
            default=self.config['total_files'],
            validate=lambda x: x.isdigit()
        ).ask_async()

        self.config['max_workers'] = await questionary.text(
            "–°–∫–æ–ª—å–∫–æ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–≥—Ä—É–∂–∞—Ç—å —Ñ–∞–π–ª–æ–≤:",
            default=self.config['max_workers'],
            validate=lambda x: x.isdigit() and int(x) > 0
        ).ask_async()

        choices = [
            questionary.Choice("üì∑ –¢–æ–ª—å–∫–æ —Ñ–æ—Ç–æ", "photo"),
            questionary.Choice("üé• –¢–æ–ª—å–∫–æ –≤–∏–¥–µ–æ", "video"),
            questionary.Choice("üì∑+üé• –í—Å–µ –º–µ–¥–∏–∞", "both")
        ]
        
        self.config['last_choice'] = await questionary.select(
            "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞:",
            choices=choices,
            default=self.config['last_choice']
        ).ask_async()

        self.save_config()

    def set_progress_callback(self, callback):
        self.progress_callback = callback

    def set_custom_input_callback(self, callback):
        self._custom_input_callback = callback

    def set_status_callback(self, callback):
        self.status_callback = callback

    def update_status(self, message, color=Fore.WHITE):
        if self.status_callback:
            self.status_callback(message)
        print(color + message + Style.RESET_ALL)

    async def init_client(self):
        async with self._auth_lock:
            if self._client is None:
                self._client = TelegramClient(
                    'tg_session', 
                    int(self.config['api_id']), 
                    self.config['api_hash']
                )
                if self._custom_input_callback:
                    self._client.set_proxy(None)
                    self._client.flood_sleep_threshold = 0
                    
                    def custom_input(prompt):
                        return self._custom_input_callback(prompt)
                        
                    self._client.phone_callback = custom_input
                    self._client.code_callback = custom_input
                    self._client.password_callback = custom_input
            
            if not self._client.is_connected():
                await self._client.connect()
                
            return self._client

    async def download_file(self, message, download_folder, semaphore, current_file, total_files):
        async with semaphore:
            try:
                if self.progress_callback:
                    progress = int((current_file / total_files) * 100)
                    self.progress_callback(progress)
                
                status_msg = f'–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞ {current_file} –∏–∑ {total_files}...'
                self.update_status(status_msg, Fore.CYAN)

                is_video = (hasattr(message, 'video') and message.video) or \
                          (hasattr(message, 'document') and 
                           hasattr(message.document, 'mime_type') and 
                           'video' in message.document.mime_type)
                
                ext = 'jpg' if hasattr(message, 'photo') and message.photo else 'mp4' if is_video else 'dat'
                filename = os.path.join(download_folder, f'media_{message.id}.{ext}')
                
                with tqdm(unit='B', unit_scale=True, desc=filename[-20:], leave=False) as pbar:
                    await self._client.download_media(
                        message,
                        file=filename,
                        progress_callback=lambda c,t: [setattr(pbar, 'total', t), pbar.update(c-pbar.n)]
                    )
                self.update_status(f'‚úÖ –§–∞–π–ª {current_file} –∑–∞–≥—Ä—É–∂–µ–Ω —É—Å–ø–µ—à–Ω–æ', Fore.GREEN)
                return True
            except Exception as e:
                error_msg = f'‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞ {current_file}: {str(e)}'
                self.update_status(error_msg, Fore.RED)
                return False

    async def run(self):
        if self.progress_callback:
            self.progress_callback(0)

        os.makedirs(self.config['download_folder'], exist_ok=True)

        try:
            self.update_status('üîÑ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏—Å—Ç–æ—á–Ω–∏–∫—É...', Fore.YELLOW)

            try:
                source = self.config['last_channel']
                if source.isdigit():
                    source_id = int(source)
                    self.update_status(f'–ü–æ–∏—Å–∫ –ø–æ ID: {source_id}...', Fore.CYAN)
                    try:
                        entity = await self._client.get_entity(InputPeerChannel(source_id, 0))
                    except ValueError:
                        try:
                            entity = await self._client.get_entity(source_id)
                        except ValueError as e:
                            self.update_status(f'‚ùå –û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∫–∞–Ω–∞–ª –∏–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å ID {source_id}', Fore.RED)
                            raise
                else:
                    username = source.lstrip('@')
                    self.update_status(f'–ü–æ–∏—Å–∫ –ø–æ –∏–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {username}...', Fore.CYAN)
                    try:
                        entity = await self._client.get_entity(username)
                    except ValueError:
                        self.update_status(f'‚ùå –û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ {username}', Fore.RED)
                        raise

                entity_type = "–∫–∞–Ω–∞–ª–∞" if hasattr(entity, "broadcast") else "–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"
                entity_name = entity.title if hasattr(entity, "title") else f"@{entity.username}" if entity.username else f"–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {entity.first_name}"
                
                self.update_status(f'‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ {entity_type}: {entity_name}', Fore.GREEN)
                
                self.update_status('üîç –ü–æ–∏—Å–∫ –º–µ–¥–∏–∞—Ñ–∞–π–ª–æ–≤...', Fore.BLUE)
                
                messages = []
                total_files = int(self.config['total_files'])
                processed_messages = 0
                found_photos = 0
                found_videos = 0
                
                try:
                    reverse = bool(self.config.get('download_order', 0))
                    self.update_status(
                        f'üîç –ü–æ–∏—Å–∫ –º–µ–¥–∏–∞—Ñ–∞–π–ª–æ–≤ {"—Å–Ω–∏–∑—É" if reverse else "—Å–≤–µ—Ä—Ö—É"}...',
                        Fore.BLUE
                    )
                    
                    async for message in self._client.iter_messages(entity, reverse=reverse):
                        try:
                            processed_messages += 1
                            is_photo = hasattr(message, 'photo') and message.photo
                            is_video = (hasattr(message, 'video') and message.video) or \
                                    (hasattr(message, 'document') and 
                                    hasattr(message.document, 'mime_type') and 
                                    'video' in message.document.mime_type)
                            
                            if is_photo:
                                found_photos += 1
                            if is_video:
                                found_videos += 1
                            
                            should_download = False
                            if self.config['last_choice'] == "photo" and is_photo:
                                should_download = True
                            elif self.config['last_choice'] == "video" and is_video:
                                should_download = True
                            elif self.config['last_choice'] == "both" and (is_photo or is_video):
                                should_download = True
                                
                            if should_download:
                                messages.append(message)
                                status_msg = (
                                    f'üìÅ –ù–∞–π–¥–µ–Ω–æ —Ñ–∞–π–ª–æ–≤ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏: {len(messages)}\n'
                                    f'üì∑ –í—Å–µ–≥–æ —Ñ–æ—Ç–æ: {found_photos}\n'
                                    f'üé• –í—Å–µ–≥–æ –≤–∏–¥–µ–æ: {found_videos}\n'
                                    f'üí¨ –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–π: {processed_messages}'
                                )
                                if total_files > 0:
                                    status_msg += f'\n‚ö° –û—Å—Ç–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏: {total_files - len(messages)}'
                                self.update_status(status_msg, Fore.CYAN)
                                
                                if total_files > 0 and len(messages) >= total_files:
                                    self.update_status(f'‚úÖ –ù–∞–π–¥–µ–Ω–æ –∑–∞–ø—Ä–æ—à–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–∞–π–ª–æ–≤: {total_files}', Fore.GREEN)
                                    break
                                
                            if processed_messages % 100 == 0:
                                self.update_status(
                                    f'üîç –ü–æ–∏—Å–∫ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è...\n'
                                    f'–ü—Ä–æ–≤–µ—Ä–µ–Ω–æ: {processed_messages} —Å–æ–æ–±—â–µ–Ω–∏–π\n'
                                    f'–ù–∞–π–¥–µ–Ω–æ —Ñ–∞–π–ª–æ–≤: {len(messages)}\n'
                                    f'–û—Å—Ç–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏: {total_files - len(messages) if total_files > 0 else "‚àû"}',
                                    Fore.BLUE
                                )
                                
                        except Exception as msg_error:
                            self.update_status(f'‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {str(msg_error)}', Fore.YELLOW)
                            continue
                            
                except Exception as iter_error:
                    self.update_status(f'‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏–π: {str(iter_error)}', Fore.RED)
                    raise

                if not messages:
                    summary_msg = (
                        f'‚ö†Ô∏è –ü–æ–¥—Ö–æ–¥—è—â–∏–µ —Ñ–∞–π–ª—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã\n'
                        f'üì∑ –í—Å–µ–≥–æ —Ñ–æ—Ç–æ: {found_photos}\n'
                        f'üé• –í—Å–µ–≥–æ –≤–∏–¥–µ–æ: {found_videos}\n'
                        f'üí¨ –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–π: {processed_messages}'
                    )
                    self.update_status(summary_msg, Fore.YELLOW)
                    return

                summary_msg = (
                    f'‚úÖ –ü–æ–∏—Å–∫ –∑–∞–≤–µ—Ä—à–µ–Ω!\n'
                    f'üì∑ –í—Å–µ–≥–æ –Ω–∞–π–¥–µ–Ω–æ —Ñ–æ—Ç–æ: {found_photos}\n'
                    f'üé• –í—Å–µ–≥–æ –Ω–∞–π–¥–µ–Ω–æ –≤–∏–¥–µ–æ: {found_videos}\n'
                    f'üí¨ –í—Å–µ–≥–æ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–π: {processed_messages}\n'
                    f'‚≠ê –ë—É–¥–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–æ: {len(messages)} —Ñ–∞–π–ª–æ–≤'
                )
                if total_files > 0 and len(messages) < total_files:
                    summary_msg += f'\n‚ö†Ô∏è –í–Ω–∏–º–∞–Ω–∏–µ: –ó–∞–ø—Ä–æ—à–µ–Ω–æ {total_files}, –Ω–æ –Ω–∞–π–¥–µ–Ω–æ —Ç–æ–ª—å–∫–æ {len(messages)} —Ñ–∞–π–ª–æ–≤'
                self.update_status(summary_msg, Fore.GREEN)

                self.update_status(f'üöÄ –ù–∞—á–∏–Ω–∞—é –∑–∞–≥—Ä—É–∑–∫—É {len(messages)} —Ñ–∞–π–ª–æ–≤ –∏–∑ {entity_type} {entity_name}...', Fore.GREEN)
                
                max_workers = int(self.config['max_workers'])
                self.update_status(f'–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è {max_workers} –ø–æ—Ç–æ–∫–æ–≤ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏', Fore.CYAN)
                
                semaphore = asyncio.Semaphore(max_workers)
                tasks = []
                
                for i, msg in enumerate(messages):
                    task = self.download_file(msg, self.config['download_folder'], semaphore, i+1, len(messages))
                    tasks.append(task)
                    self.update_status(f'–î–æ–±–∞–≤–ª–µ–Ω–∞ –∑–∞–¥–∞—á–∞ –∑–∞–≥—Ä—É–∑–∫–∏ {i+1}/{len(messages)}', Fore.CYAN)
                
                self.update_status('–ó–∞–ø—É—Å–∫ –∑–∞–¥–∞—á –∑–∞–≥—Ä—É–∑–∫–∏...', Fore.CYAN)
                results = await asyncio.gather(*tasks, return_exceptions=True)
                
                success_count = sum(1 for r in results if r is True)
                error_count = len(messages) - success_count
                
                print("\n" + "="*50 + "\n")
                
                result_msg = (
                    f'üìä –ó–∞–≥—Ä—É–∑–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\n'
                    f'‚úÖ –£—Å–ø–µ—à–Ω–æ: {success_count}\n'
                    f'‚ùå –û—à–∏–±–∫–∏: {error_count}\n'
                    f'üìÅ –ü–∞–ø–∫–∞: {os.path.abspath(self.config["download_folder"])}'
                )
                self.update_status(result_msg, Fore.GREEN)

            except Exception as e:
                error_msg = f'‚ùå –û—à–∏–±–∫–∞: {str(e)}'
                self.update_status(error_msg, Fore.RED)
                raise

        finally:
            if self._client:
                await self._client.disconnect()
                self.update_status('–û—Ç–∫–ª—é—á–µ–Ω–æ –æ—Ç Telegram', Fore.YELLOW)

class TelegramDownloaderGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.downloader = TelegramMediaDownloader()
        self.auth_dialog = None
        self.auth_in_progress = False
        self.download_task = None
        self.is_paused = False
        self.is_stopped = False
        
        self.downloader.set_custom_input_callback(self.handle_telethon_input)
        self.downloader.set_status_callback(lambda text: self.status_label.setText(text))
        
        self.gui_output = GuiOutput(self.handle_console_output)
        sys.stdout = self.gui_output
        sys.stderr = self.gui_output
        
        self.init_ui()
        self.setup_animations()
        
    def setup_animations(self):
        self.button_animations = {}
        for btn in [self.start_btn, self.pause_btn, self.stop_btn]:
            animation = QPropertyAnimation(btn, b"minimumSize")
            animation.setDuration(100)
            animation.setEasingCurve(QEasingCurve.Type.OutCubic)
            self.button_animations[btn] = animation
            
        self.progress_animation = QPropertyAnimation(self.progress, b"value")
        self.progress_animation.setDuration(500)
        self.progress_animation.setEasingCurve(QEasingCurve.Type.OutCubic)
        
    def animate_button(self, button, pressed=True):
        if button in self.button_animations:
            animation = self.button_animations[button]
            current_size = button.size()
            if pressed:
                animation.setStartValue(current_size)
                animation.setEndValue(QSize(current_size.width() - 5, current_size.height() - 5))
            else:
                animation.setStartValue(current_size)
                animation.setEndValue(QSize(current_size.width() + 5, current_size.height() + 5))
            animation.start()
            
    def animate_progress(self, value):
        self.progress_animation.setStartValue(self.progress.value())
        self.progress_animation.setEndValue(value)
        self.progress_animation.start()
        
    def init_ui(self):
        self.setWindowTitle('Telegram Media Downloader Pro (@GODIS0)')
        self.setFixedSize(600, 550)
        
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)
        layout.setSpacing(10)
        
        api_group = QGroupBox('–ù–∞—Å—Ç—Ä–æ–π–∫–∏ API Telegram')
        api_layout = QVBoxLayout()
        
        api_id_layout = QHBoxLayout()
        self.api_id = QLineEdit(self.downloader.config['api_id'])
        self.api_id.setPlaceholderText('–í–≤–µ–¥–∏—Ç–µ API ID')
        api_id_layout.addWidget(QLabel('API ID:'))
        api_id_layout.addWidget(self.api_id)
        api_id_help = QPushButton('?')
        api_id_help.setFixedSize(25, 25)
        api_id_help.clicked.connect(lambda: QMessageBox.information(self, '–ü–æ–º–æ—â—å',
            'API ID –º–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –Ω–∞ my.telegram.org\n'
            '1. –í–æ–π–¥–∏—Ç–µ –≤ —Å–≤–æ–π –∞–∫–∫–∞—É–Ω—Ç\n'
            '2. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ "API development tools"\n'
            '3. –°–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ'))
        api_id_layout.addWidget(api_id_help)
        api_layout.addLayout(api_id_layout)
        
        api_hash_layout = QHBoxLayout()
        self.api_hash = QLineEdit(self.downloader.config['api_hash'])
        self.api_hash.setPlaceholderText('–í–≤–µ–¥–∏—Ç–µ API Hash')
        api_hash_layout.addWidget(QLabel('API Hash:'))
        api_hash_layout.addWidget(self.api_hash)
        api_hash_help = QPushButton('?')
        api_hash_help.setFixedSize(25, 25)
        api_hash_help.clicked.connect(lambda: QMessageBox.information(self, '–ü–æ–º–æ—â—å',
            'API Hash –º–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å —Ç–∞–º –∂–µ, –≥–¥–µ –∏ API ID\n'
            '–≠—Ç–æ –¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ —Å–∏–º–≤–æ–ª–æ–≤ –ø–æ–¥ API ID'))
        api_hash_layout.addWidget(api_hash_help)
        api_layout.addLayout(api_hash_layout)
        
        self.check_auth_btn = QPushButton('–í–æ–π—Ç–∏ –≤ Telegram')
        self.check_auth_btn.clicked.connect(self.check_auth)
        api_layout.addWidget(self.check_auth_btn)
        
        api_group.setLayout(api_layout)
        layout.addWidget(api_group)
        
        download_group = QGroupBox('–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∑–∞–≥—Ä—É–∑–∫–∏')
        download_layout = QVBoxLayout()
        
        source_layout = QHBoxLayout()
        self.channel = QLineEdit(self.downloader.config['last_channel'])
        self.channel.setPlaceholderText('–ù–∞–ø—Ä–∏–º–µ—Ä: @channel –∏–ª–∏ @username')
        source_layout.addWidget(QLabel('–ò—Å—Ç–æ—á–Ω–∏–∫:'))
        source_layout.addWidget(self.channel)
        source_help = QPushButton('?')
        source_help.setFixedSize(25, 25)
        source_help.clicked.connect(lambda: QMessageBox.information(self, '–ü–æ–º–æ—â—å',
            '–í–≤–µ–¥–∏—Ç–µ:\n'
            '‚Ä¢ @username –∫–∞–Ω–∞–ª–∞ –∏–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n'
            '‚Ä¢ ID –∫–∞–Ω–∞–ª–∞\n'
            '‚Ä¢ –°—Å—ã–ª–∫—É –Ω–∞ –∫–∞–Ω–∞–ª'))
        source_layout.addWidget(source_help)
        download_layout.addLayout(source_layout)
        
        folder_layout = QHBoxLayout()
        self.folder_path = QLineEdit(self.downloader.config['download_folder'])
        self.folder_path.setPlaceholderText('–ü—É—Ç—å –∫ –ø–∞–ø–∫–µ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è')
        folder_layout.addWidget(QLabel('–ü–∞–ø–∫–∞:'))
        folder_layout.addWidget(self.folder_path)
        self.folder_btn = QPushButton('–í—ã–±—Ä–∞—Ç—å')
        self.folder_btn.clicked.connect(self.select_folder)
        folder_layout.addWidget(self.folder_btn)
        download_layout.addLayout(folder_layout)
        
        counts_layout = QHBoxLayout()
        
        files_layout = QVBoxLayout()
        files_layout.addWidget(QLabel('–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–∞–π–ª–æ–≤:'))
        self.total_files = QLineEdit(self.downloader.config['total_files'])
        self.total_files.setPlaceholderText('0 = –≤—Å–µ —Ñ–∞–π–ª—ã')
        files_layout.addWidget(self.total_files)
        counts_layout.addLayout(files_layout)
        
        workers_layout = QVBoxLayout()
        workers_layout.addWidget(QLabel('–ü–æ—Ç–æ–∫–æ–≤ –∑–∞–≥—Ä—É–∑–∫–∏:'))
        self.max_workers = QLineEdit(self.downloader.config['max_workers'])
        self.max_workers.setPlaceholderText('–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è: 3-5')
        workers_layout.addWidget(self.max_workers)
        counts_layout.addLayout(workers_layout)
        
        download_layout.addLayout(counts_layout)
        
        content_layout = QHBoxLayout()
        content_layout.addWidget(QLabel('–¢–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞:'))
        self.content_type = QComboBox()
        self.content_type.addItems(['–¢–æ–ª—å–∫–æ —Ñ–æ—Ç–æ', '–¢–æ–ª—å–∫–æ –≤–∏–¥–µ–æ', '–í—Å–µ –º–µ–¥–∏–∞—Ñ–∞–π–ª—ã'])
        content_layout.addWidget(self.content_type)
        download_layout.addLayout(content_layout)
        
        order_layout = QHBoxLayout()
        order_layout.addWidget(QLabel('–ü–æ—Ä—è–¥–æ–∫ –∑–∞–≥—Ä—É–∑–∫–∏:'))
        self.download_order = QComboBox()
        self.download_order.addItems(['–° –Ω–∞—á–∞–ª–∞ —á–∞—Ç–∞ (—Å–≤–µ—Ä—Ö—É)', '–° –∫–æ–Ω—Ü–∞ —á–∞—Ç–∞ (—Å–Ω–∏–∑—É)'])
        order_layout.addWidget(self.download_order)
        download_layout.addLayout(order_layout)
        
        download_group.setLayout(download_layout)
        layout.addWidget(download_group)
        
        progress_group = QGroupBox('–ü—Ä–æ–≥—Ä–µ—Å—Å –∑–∞–≥—Ä—É–∑–∫–∏')
        progress_layout = QVBoxLayout()
        
        self.progress = QProgressBar()
        self.progress.setStyleSheet("""
            QProgressBar {
                border: 2px solid #2196F3;
                border-radius: 5px;
                text-align: center;
                background-color: #E3F2FD;
            }
            QProgressBar::chunk {
                background-color: #2196F3;
                border-radius: 3px;
            }
        """)
        progress_layout.addWidget(self.progress)
        
        self.status_label = QLabel('')
        self.status_label.setWordWrap(True)
        self.status_label.setStyleSheet('color: green;')
        progress_layout.addWidget(self.status_label)
        
        progress_group.setLayout(progress_layout)
        layout.addWidget(progress_group)
        
        control_layout = QHBoxLayout()
        
        self.start_btn = QPushButton('–°—Ç–∞—Ä—Ç')
        self.start_btn.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 5px;
                padding: 10px 20px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
            QPushButton:pressed {
                background-color: #1565C0;
            }
        """)
        self.start_btn.clicked.connect(self.on_download_clicked)
        control_layout.addWidget(self.start_btn)
        
        self.pause_btn = QPushButton('–ü–∞—É–∑–∞')
        self.pause_btn.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 5px;
                padding: 10px 20px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
            QPushButton:pressed {
                background-color: #1565C0;
            }
        """)
        self.pause_btn.clicked.connect(self.toggle_pause)
        self.pause_btn.setEnabled(False)
        control_layout.addWidget(self.pause_btn)
        
        self.stop_btn = QPushButton('–°—Ç–æ–ø')
        self.stop_btn.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 5px;
                padding: 10px 20px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
            QPushButton:pressed {
                background-color: #1565C0;
            }
        """)
        self.stop_btn.clicked.connect(self.stop_download)
        self.stop_btn.setEnabled(False)
        control_layout.addWidget(self.stop_btn)
        
        layout.addLayout(control_layout)
        
        bottom_layout = QHBoxLayout()

        author_label = QLabel('Created by @GODIS & @h1qzeks')
        author_label.setAlignment(Qt.AlignmentFlag.AlignLeft)
        author_label.setStyleSheet('color: gray;')
        
        support_label = QLabel('<a href="https://www.donationalerts.com/r/h1qzeks">–ü–æ–¥–¥–µ—Ä–∂–∞—Ç—å</a>')
        support_label.setAlignment(Qt.AlignmentFlag.AlignRight)
        support_label.setStyleSheet('''
            QLabel {
                color: #2196F3;
                text-decoration: none;
            }
            QLabel:hover {
                color: #1976D2;
            }
        ''')
        support_label.setOpenExternalLinks(True)
        
        bottom_layout.addWidget(author_label)
        bottom_layout.addWidget(support_label)
        layout.addLayout(bottom_layout)
        
    def select_folder(self):
        folder = QFileDialog.getExistingDirectory(self, '–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞–ø–∫—É –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è')
        if folder:
            self.folder_path.setText(folder)
            
    def on_download_clicked(self):
        loop = asyncio.get_event_loop()
        task = loop.create_task(self.start_download())
        task.add_done_callback(self.handle_download_complete)
        
    def handle_download_complete(self, future):
        try:
            future.result()
        except Exception as e:
            self.status_label.setText(f'–û—à–∏–±–∫–∞: {str(e)}')
        finally:
            self.start_btn.setEnabled(True)
            self.pause_btn.setEnabled(False)
            self.stop_btn.setEnabled(False)
            
    def handle_console_output(self, text):
        if hasattr(self, 'auth_status'):
            clean_text = text.replace(Fore.YELLOW, '').replace(Fore.GREEN, '')\
                            .replace(Fore.RED, '').replace(Fore.CYAN, '')\
                            .replace(Fore.BLUE, '').replace(Style.RESET_ALL, '')
            clean_text = clean_text.strip()
            if clean_text:
                self.auth_status.setText(clean_text)
                
    def handle_telethon_input(self, prompt):
        if "phone" in prompt.lower():
            return self.phone_input.text().strip() + "\n"
        elif "code" in prompt.lower():
            return self.code_input.text().strip() + "\n"
        elif "password" in prompt.lower() or "2fa" in prompt.lower():
            return self.password_input.text().strip() + "\n"
        return "\n"

    def create_auth_dialog(self):
        dialog = QDialog(self)
        dialog.setWindowTitle('–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è Telegram')
        dialog.setModal(True)
        layout = QVBoxLayout(dialog)
        
        phone_label = QLabel('–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞:')
        self.phone_input = QLineEdit()
        self.phone_input.setPlaceholderText('+79999999999')
        layout.addWidget(phone_label)
        layout.addWidget(self.phone_input)
        
        code_label = QLabel('–ö–æ–¥ –∏–∑ Telegram:')
        self.code_input = QLineEdit()
        self.code_input.setPlaceholderText('12345')
        self.code_input.hide()
        code_label.hide()
        layout.addWidget(code_label)
        layout.addWidget(self.code_input)
        
        password_label = QLabel('–ü–∞—Ä–æ–ª—å –¥–≤—É—Ö—Ñ–∞–∫—Ç–æ—Ä–Ω–æ–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏:')
        self.password_input = QLineEdit()
        self.password_input.setPlaceholderText('–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å 2FA')
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.password_input.hide()
        password_label.hide()
        layout.addWidget(password_label)
        layout.addWidget(self.password_input)
        
        button_box = QHBoxLayout()
        self.send_code_btn = QPushButton('–û—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–æ–¥')
        self.send_code_btn.clicked.connect(self.handle_send_code)
        self.verify_code_btn = QPushButton('–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å')
        self.verify_code_btn.clicked.connect(self.handle_verify_code)
        self.verify_code_btn.hide()
        
        button_box.addWidget(self.send_code_btn)
        button_box.addWidget(self.verify_code_btn)
        layout.addLayout(button_box)
        
        self.auth_status = QLabel('')
        layout.addWidget(self.auth_status)
        
        return dialog
        
    def handle_send_code(self):
        if self.auth_in_progress:
            return
            
        phone = self.phone_input.text().strip()
        if not phone:
            self.auth_status.setText('–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞!')
            return
            
        self.auth_in_progress = True
        self.send_code_btn.setEnabled(False)
        self.auth_status.setText('–û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–¥–∞...')
        
        async def send_code():
            try:
                client = await self.downloader.init_client()
                await client.send_code_request(phone)
                
                self.auth_status.setText('–ö–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω! –í–≤–µ–¥–∏—Ç–µ –µ–≥–æ –Ω–∏–∂–µ.')
                self.code_input.show()
                self.code_input.parentWidget().findChild(QLabel, '', Qt.FindChildOption.FindDirectChildrenOnly).show()
                self.verify_code_btn.show()
                self.code_input.setFocus()
                
            except Exception as e:
                self.auth_status.setText(f'–û—à–∏–±–∫–∞: {str(e)}')
                self.send_code_btn.setEnabled(True)
            finally:
                self.auth_in_progress = False
        
        asyncio.create_task(send_code())
        
    def handle_verify_code(self):
        if self.auth_in_progress:
            return
            
        phone = self.phone_input.text().strip()
        code = self.code_input.text().strip()
        if not code:
            self.auth_status.setText('–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥!')
            return
            
        self.auth_in_progress = True
        self.verify_code_btn.setEnabled(False)
        self.auth_status.setText('–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–¥–∞...')
        
        async def verify():
            try:
                client = await self.downloader.init_client()
                try:
                    await client.sign_in(phone, code)
                except telethon.errors.SessionPasswordNeededError:
                    self.auth_status.setText('–¢—Ä–µ–±—É–µ—Ç—Å—è –ø–∞—Ä–æ–ª—å –¥–≤—É—Ö—Ñ–∞–∫—Ç–æ—Ä–Ω–æ–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏')
                    self.password_input.show()
                    self.password_input.parentWidget().findChild(QLabel, '', Qt.FindChildOption.FindDirectChildrenOnly).show()
                    self.password_input.setFocus()
                    self.verify_code_btn.setText('–í–æ–π—Ç–∏')
                    self.verify_code_btn.setEnabled(True)
                    return
                
                self.auth_status.setText('–£—Å–ø–µ—à–Ω–∞—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è!')
                self.status_label.setText('‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞')
                self.auth_dialog.accept()
                
            except Exception as e:
                if "2FA" in str(e) or "password" in str(e).lower():
                    self.auth_status.setText('–¢—Ä–µ–±—É–µ—Ç—Å—è –ø–∞—Ä–æ–ª—å –¥–≤—É—Ö—Ñ–∞–∫—Ç–æ—Ä–Ω–æ–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏')
                    self.password_input.show()
                    self.password_input.parentWidget().findChild(QLabel, '', Qt.FindChildOption.FindDirectChildrenOnly).show()
                    self.password_input.setFocus()
                    self.verify_code_btn.setText('–í–æ–π—Ç–∏')
                    self.verify_code_btn.setEnabled(True)
                else:
                    self.auth_status.setText(f'–û—à–∏–±–∫–∞: {str(e)}')
                    self.verify_code_btn.setEnabled(True)
            finally:
                self.auth_in_progress = False
        
        if self.password_input.isVisible():
            password = self.password_input.text().strip()
            if not password:
                self.auth_status.setText('–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å 2FA!')
                self.verify_code_btn.setEnabled(True)
                return
                
            async def verify_2fa():
                try:
                    client = await self.downloader.init_client()
                    await client.sign_in(password=password)
                    self.auth_status.setText('–£—Å–ø–µ—à–Ω–∞—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è!')
                    self.status_label.setText('‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞')
                    self.auth_dialog.accept()
                except Exception as e:
                    self.auth_status.setText(f'–û—à–∏–±–∫–∞: {str(e)}')
                    self.verify_code_btn.setEnabled(True)
                finally:
                    self.auth_in_progress = False
                    
            asyncio.create_task(verify_2fa())
        else:
            asyncio.create_task(verify())
        
    def check_auth(self):
        if self.auth_in_progress:
            return
            
        if not self.api_id.text() or not self.api_hash.text():
            self.status_label.setText('–°–Ω–∞—á–∞–ª–∞ –≤–≤–µ–¥–∏—Ç–µ API ID –∏ API Hash!')
            return
            
        self.auth_in_progress = True
        self.check_auth_btn.setEnabled(False)
        
        async def check():
            try:
                self.downloader.config['api_id'] = self.api_id.text()
                self.downloader.config['api_hash'] = self.api_hash.text()
                self.downloader.save_config()
                
                client = await self.downloader.init_client()
                
                if not await client.is_user_authorized():
                    if self.auth_dialog is None:
                        self.auth_dialog = self.create_auth_dialog()
                    self.auth_dialog.show()
                else:
                    self.status_label.setText('‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞')
                    
            except Exception as e:
                self.status_label.setText(f'–û—à–∏–±–∫–∞: {str(e)}')
            finally:
                self.check_auth_btn.setEnabled(True)
                self.auth_in_progress = False
        
        asyncio.create_task(check())
        
    def toggle_pause(self):
        if self.is_paused:
            self.is_paused = False
            self.pause_btn.setText('–ü–∞—É–∑–∞')
            self.status_label.setText('–ó–∞–≥—Ä—É–∑–∫–∞ –≤–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω–∞')
            self.animate_progress(self.progress.value())
        else:
            self.is_paused = True
            self.pause_btn.setText('–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å')
            self.status_label.setText('–ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞')
            
    def stop_download(self):
        self.is_stopped = True
        self.is_paused = False
        self.start_btn.setEnabled(True)
        self.pause_btn.setEnabled(False)
        self.stop_btn.setEnabled(False)
        self.status_label.setText('–ó–∞–≥—Ä—É–∑–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞')
        self.animate_progress(0)
        
    async def start_download(self):
        if not self.api_id.text() or not self.api_hash.text() or not self.channel.text():
            self.status_label.setText('–û—à–∏–±–∫–∞: –ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è!')
            return

        self.progress.setValue(0)
        self.start_btn.setEnabled(False)
        self.pause_btn.setEnabled(True)
        self.stop_btn.setEnabled(True)
        self.is_paused = False
        self.is_stopped = False
        self.status_label.setText('–ó–∞–≥—Ä—É–∑–∫–∞ –Ω–∞—á–∞—Ç–∞...')
        
        try:
            self.downloader.config['api_id'] = self.api_id.text()
            self.downloader.config['api_hash'] = self.api_hash.text()
            self.downloader.config['last_channel'] = self.channel.text()
            self.downloader.config['download_folder'] = self.folder_path.text()
            self.downloader.config['total_files'] = self.total_files.text()
            self.downloader.config['max_workers'] = self.max_workers.text()
            self.downloader.config['last_choice'] = ['photo', 'video', 'both'][
                self.content_type.currentIndex()]
            self.downloader.config['download_order'] = self.download_order.currentIndex()
            
            self.downloader.save_config()
            
            if not await self.downloader._client.is_user_authorized():
                self.status_label.setText('–ù–µ–æ–±—Ö–æ–¥–∏–º–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è!')
                await self.check_auth()
                return
            
            self.downloader.set_progress_callback(lambda p: self.animate_progress(p))
            
            old_stdout = sys.stdout
            sys.stdout = self.gui_output
            try:
                self.download_task = asyncio.create_task(self.downloader.run())
                await self.download_task
                if not self.is_stopped:
                    self.status_label.setText('–ó–∞–≥—Ä—É–∑–∫–∞ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!')
                    self.animate_progress(100)
            finally:
                sys.stdout = old_stdout
                self.start_btn.setEnabled(True)
                self.pause_btn.setEnabled(False)
                self.stop_btn.setEnabled(False)
            
        except Exception as e:
            self.status_label.setText(f'–û—à–∏–±–∫–∞: {str(e)}')
            self.start_btn.setEnabled(True)
            self.pause_btn.setEnabled(False)
            self.stop_btn.setEnabled(False)
            raise

    def closeEvent(self, event):
        sys.stdout = sys.__stdout__
        super().closeEvent(event)

def main():
    app = QApplication(sys.argv)
    
    loop = QEventLoop(app)
    asyncio.set_event_loop(loop)
    
    window = TelegramDownloaderGUI()
    window.show()
    
    with loop:
        loop.run_forever()

if __name__ == '__main__':
    main()
